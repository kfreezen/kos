#include <paging.h>
#include <common/bitset.h>
#include <kheap.h>
#include <print.h>

#define PAGING_DEBUG
#define PAGING_DEBUG_VERBOSE

Bitset* pages;
PageDirectory* pageDir;
PageDirectory* currentPageDir;

extern UInt32 placement_address;

extern void _invlpg(void* ptr);

UInt32 AllocPage() {
	#ifdef PAGING_DEBUG
	kprintf("AllocPage()\n");
	#endif
	
	UInt32 ret = Bitset_FirstWithValue(pages, 0);
	Bitset_Set(pages, ret, 1);
	return ret;
}

UInt32 AllocPageBlock() {
	#ifdef PAGING_DEBUG
	kprintf("AllocPageBlock()\n");
	#endif
	
	UInt32 i;
	for(i=0; i<pages->length; i++) {
		if(!pages->bitData[i]) { // This is an entire free page block.
			pages->bitData[i] = ~0;
		}
	}
	
	return i*32;
}

PageDirectoryEntry AssemblePDE(PageTable* table, UInt32 flags) {
	if((unsigned)table&0xFFF) {
		asm volatile("int $13");
		return 0;
	}
	
	return (UInt32) table | (flags&0xFFF);
}

PageTableEntry AssemblePTE(void* address, UInt32 flags) {
	#ifdef PAGING_DEBUG_VERBOSE
	kprintf("AssemblePTE(%x, %x)\n", address, flags);
	#endif
	
	address = (void*) ((unsigned)address & 0xFFFFF000);
	return (UInt32) address | (flags&0xFFF);
}

extern void switch_page_dir(void* ptr);

void SwitchPageDirectory(PageDirectory* dir) {
	currentPageDir = dir;
	switch_page_dir(dir->d);
}

void InitPaging(int mem_kb) {
	UInt32 phys = 0;
	
	pages = kmalloc(sizeof(Bitset));
	int pagesAmount = mem_kb/4;
	pages->bitData = (void*) kmalloc(pagesAmount/32);
	pages->length = pagesAmount/32;
	
	// Do 1 to 1 paging on everything up to placement_address.
	pageDir = (PageDirectory*) kmalloc_ap(sizeof(PageDirectory), &phys);
	pageDir->d[1023] = (PageDirectoryEntry) pageDir->d;
	pageDir->phys = phys;
	
	kprintf("pages->bitData=%x\n", pages->bitData);
	
	memset(pages->bitData, 0, pages->length);
	memset(pageDir, 0, sizeof(PageDirectory));
	
	// Get the amount of Page tables we will need to map up to placement address.
	if(placement_address&0xFFFFF000) {
		placement_address = (placement_address&0xFFFFF000)+0x1000;
	}
	
	// Horrible code readability by having this variable take on two roles in seperate parts of the code.
	
	pagesAmount = placement_address>>12;
	int pageTablesAmount = pagesAmount>>10;
	if(pagesAmount & 0x3FF) {
		pageTablesAmount+=1;
	}
	
	int pagesNeededToRepresentTables = pageTablesAmount;
	int extraPageTables = pagesNeededToRepresentTables>>10;
	if(pagesNeededToRepresentTables & 0x3FF) {
		extraPageTables += 1;
	}
	
	int totalPageTables = pageTablesAmount+extraPageTables;
	
	int i;
	for(i=0; i<totalPageTables; i++) {
		PageTable* table = (PageTable*) kmalloc_ap(sizeof(PageTable), &phys);
		int j;
		for(j=0; j<1024; j++) {
			// kernel page flags = AAAGS0ADWURP
			//                   = 000000000011
			table->t[j] = AssemblePTE((void*)(i<<22)+(j<<12), KERNEL_PAGE_FLAGS);
			
			// The extra 0x4000 is for working room for page tables.
			if((i<<22)+(j<<12)>placement_address+0x4000 && i >= totalPageTables-1) {
				break;	
			}
		}
		
		pageDir->d[i] = AssemblePDE(table, KERNEL_PAGE_FLAGS);
		pageDir->kd[i] = phys;
	}
	
	for(i=0; i<pageTablesAmount+extraPageTables*1024/32; i++) {
		pages->bitData[i] = ~0;
	}
	SwitchPageDirectory(pageDir);
}

PageTable* createNewPageTable(PageDirectory* dir, void* virtualAddr) {
	#ifdef PAGING_DEBUG
	kprintf("createNewPageTable(%x, %x)\n", dir, virtualAddr);
	#endif
	
	if(dir==NULL) {
		dir = currentPageDir;
	}
	
	UInt32 phys=0;
	PageTable* table = kmalloc_ap(0x1000, &phys);
	
	int pdindex = ((unsigned)virtualAddr)>>22;
	
	dir->d[pdindex] = AssemblePDE(table, KERNEL_PAGE_FLAGS);
	dir->kd[pdindex] = phys;
	
	return table;
}

int MapAllocatedPageBlockTo(PageDirectory* dir, void* virtualAddr) {
	#ifdef PAGING_DEBUG
	kprintf("MapAllocatedPageBlockTo(%x, %x)\n", dir, virtualAddr);
	#endif
	
	if(dir==NULL) {
		dir = currentPageDir;
	}
	
	if((unsigned)virtualAddr&0xFFF) {
		virtualAddr = (void*) ((unsigned)virtualAddr & 0xFFFFF000);
	}
	
	UInt32 pd_index = ((unsigned)virtualAddr)>>22;
	UInt32 pt_index = ((unsigned)virtualAddr)>>12 & 0x3FF;
	
	if(!(dir->d[pd_index] & PAGE_PRESENT)) {
		createNewPageTable(dir, virtualAddr);
	} else {
		PageTable* table = (PageTable*) (dir->d[pd_index]&0xFFFFF000);
		
		// Now make sure that all are empty.
		int i;
		for(i=0; i<32; i++) {
			if(pt_index+i>=1024) {
				break;
			}
			
			if(table->t[pt_index+i]&PAGE_PRESENT) {
				kprintf("ERROR:  Page %d in page block is already mapped.\n", i);
				return -1;
			}
		}
		
		if(i<32) {
			table = (PageTable*) (dir->d[pd_index+1]&0xFFFFF000);
		
			int j;
			for(j=0; j<(32-i); j++) {
				if(table->t[pt_index+i]&PAGE_PRESENT) {
					kprintf("ERROR:  Page %d in page block is already mapped.\n", i);
					return -1;
				}
			}
			table = (PageTable*) (dir->d[pd_index]&0xFFFFF000);
		}
		
		UInt32 page = AllocPageBlock();
		
		for(i=0; i<32; i++) {
			if(pt_index+i>=1024) {
				break;
			}
			table->t[pt_index+i] = AssemblePTE((void*)((page+i)<<12), KERNEL_PAGE_FLAGS);
			_invlpg(virtualAddr);
		}
		
		if(!(dir->d[pd_index+1]&PAGE_PRESENT)) {
			createNewPageTable(dir, virtualAddr);
		}
		
		if(i<32) {
			int j;
			table = (PageTable*) (dir->d[pd_index+1]&0xFFFFF000);
			for(j=0; j<(32-i); j++) {
				table->t[pt_index+i] = AssemblePTE((void*)((page+i)<<12), KERNEL_PAGE_FLAGS);
				_invlpg(virtualAddr);
			}
		}
	}
	
	return 0;
}

void* getPhysAddr(PageDirectory* dir, void* virt) {
	if(dir==NULL) {
		dir=currentPageDir;
	}
	
	int pdindex = ((unsigned)virt)>>22;
	int ptindex = ((unsigned)virt)>>12 & 0x3FF;
	
	PageTable* table = (PageTable*) ((unsigned)dir->d[pdindex]&0xFFFFF000);
	return (void*)((unsigned)table->t[ptindex] & 0xFFFFF000);
}

int MapAllocatedPageTo(PageDirectory* dir, void* virtualAddr) {
	#ifdef PAGING_DEBUG
	kprintf("MapAllocatedPageTo(%x, %x)\n", dir, virtualAddr);
	#endif
	
	if(dir==NULL) {
		dir = currentPageDir;
	}
	
	if((unsigned)virtualAddr&0xFFF) {
		virtualAddr = (void*) ((unsigned)virtualAddr & 0xFFFFF000);
	}
	
	int pd_index = ((unsigned)virtualAddr)>>22;
	int pt_index = ((unsigned)virtualAddr)>>12 & 0x03FF;
	
	if(!(dir->d[pd_index] & PAGE_PRESENT)) {
		createNewPageTable(dir, virtualAddr);
		//kprintf("Error:  Adding page table not supported (yet).");
	}
	
	PageTable* table = (PageTable*) (dir->d[pd_index]&0xFFFFF000);
	if(table->t[pt_index]&PAGE_PRESENT) {
		// You should know better than to try mapping something to an already present page.
		kprintf("ERROR:  Page is already mapped.\n");
		return -1;
	} else {
		UInt32 physAddr = AllocPage()<<12;
		//kprintf("physAddr=%x\n", physAddr);
		
		table->t[pt_index] = AssemblePTE((void*)physAddr, KERNEL_PAGE_FLAGS);
		_invlpg(virtualAddr);
	}
	
	return 0;
}
