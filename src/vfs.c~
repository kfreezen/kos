#include <vfs.h>
#include <common/arraylist.h>

fs_node_t *fs_root = 0; // The root of the filesystem.

int vfs_inodes_int=1;
ArrayList TYPE(fs_node_t*)* vfs_nodes;

void VFS_Init() {
	fs_root = (fs_node_t*) kalloc(sizeof(fs_node_t));
	
	fs_root->name = (char*) kalloc(4);
	strcpy(fs_root->name, "fs");
	
	fs_root->flags = FS_ROOT_DIR;
	fs_root->inode = 0;
	
	vfs_nodes = ALCreate();
	kprintf("vfs_nodes=%x\n", vfs_nodes);
}

UInt32 read_fs(fs_node_t *node, UInt32 offset, UInt32 size, UInt8 *buffer)
{
  // Has the node got a read callback?
  if (node->read != 0)
    return node->read(node, offset, size, buffer);
  else
    return 0;
}

UInt32 write_fs(fs_node_t *node, UInt32 offset, UInt32 size, UInt8 *buffer)
{
  // Has the node got a write callback?
  if (node->write != 0)
    return node->write(node, offset, size, buffer);
  else
    return 0;
} 

void open_fs(fs_node_t *node)
{
  // Has the node got a read callback?
  if (node->open != 0)
    node->open(node);
  else
    return;
} 

void close_fs(fs_node_t *node)
{
  // Has the node got a read callback?
  if (node->close != 0)
    node->close(node);
  else
    return;
}

struct dirent *readdir_fs(fs_node_t *node, UInt8 index) {
	if(node->readdir!=0 && (node->flags&0x7)==FS_DIRECTORY) {
		return node->readdir(node, index);
	} else {
		return 0;
	}
}

fs_node_t *finddir_fs(fs_node_t *node, char *name) {
	kprintf("node=%x\n", node);
	if(node->finddir!=0 && (node->flags&0x7)==FS_DIRECTORY) {
		return node->finddir(node, name);
	} else {
		// Scan the vfs_nodes thingy.
		int i;
		for(i=0; i<vfs_nodes->length; i++) {
			fs_node_t* searchNode = (fs_node_t*) ALGetPtr(vfs_nodes, i);
			if(!strncmp(searchNode->name, FS_NAME_LEN, name)) {
				kprintf("FOUND!\n");
				return searchNode;
			}
		}
		
		return NULL;
	}
}

fs_node_t* open_file(fs_node_t* root, const char* file) {
	int i=0;
	struct dirent* node = 0;
	while((node = readdir_fs(root, i)) != 0) {
		fs_node_t* fsnode = finddir_fs(root, node->name);
		
		if(!strcmp(node->name, file) && (fsnode->flags&0x7) != FS_DIRECTORY) {
			// We've found our match
			
			kprintf("length=%d\n", fsnode->length);
			
			return fsnode;
		}
		
		i++;
	}
	
	return NULL;
}

#define MAX_FILENAME_LENGTH 512

fs_node_t* open_file_fs(fs_node_t* root, const char* filename) {
	if(filename[0]=='/' || root==NULL) {
		root = fs_root;
	}
	
	if(root==NULL) {
		return NULL;
	}
	
	int i=1;
	int j=(filename[0]=='/')?1:0;
	
	fs_node_t* curNode = root;
	
	char file[128];
	
	strncpy(file, 127, filename);
	file[127] = 0;
	
	while(1) {
		// Find '/'
		for(; file[i]!=0 && i<MAX_FILENAME_LENGTH; i++) {
			if(file[i]=='/') {
				file[i++] = 0;
				break;
			}
		}
		
		kprintf("curNodeBefore=%x:%s\n", curNode, &file[j]);
		curNode = finddir_fs(curNode, &file[j]);
		kprintf("curNode=%x\n", curNode);
		
		if(curNode==NULL) {
			return NULL;
		}
		
		j = i;
	}
	
	return curNode;
	
}

void mount(Device* device, FSDriver* driver, const char* mountpoint) {
	fs_node_t* root = NULL;
	
	if(driver->createMount!=NULL) {
		root = driver->createMount(device);
	}
	
	if(root==NULL) {
		kprintf("Root is still NULL: mount(%x, %x, %s)\n", device, driver, mountpoint);
		return;
	}

	
	fs_node_t* mountNode = (fs_node_t*) kalloc(sizeof(fs_node_t));
	kprintf("mount=%x, root=%x\n", mountNode, root);
	mountNode->ptr = root;
	mountNode->name = kalloc(strlen(mountpoint)+1);
	
	strcpy(mountNode->name, mountpoint);
	mountNode->inode = ALAdd(vfs_nodes, mountNode);
}
